def parse-solidfire-logs [file_path: string] {
  open $file_path
  | lines
  | each { |line|
      let parts = ($line | parse --regex '([^:]+):(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d+Z)\s+(\S+)\s+([^:]+):\s*(.*)')
      if ($parts | length) > 0 {
        let parsed = $parts.0
        let message = $parsed.capture4

        # Extract fault information if present
        let fault_info = if ($message | str contains "clusterFault=") {
          let fault_match = ($message | parse --regex 'clusterFault=\{([^}]+)\}')
          if ($fault_match | length) > 0 {
            let fault_details = $fault_match.0.capture0
            let fault_parts = ($fault_details | parse --regex 'id=(\d+).*?type=(\w+).*?severity=(\w+).*?code=(\w+).*?nodeID=(\d+).*?serviceID=(\d+)')
            if ($fault_parts | length) > 0 {
              {
                fault_id: ($fault_parts.0.capture0 | into int),
                type: $fault_parts.0.capture1,
                severity: $fault_parts.0.capture2,
                code: $fault_parts.0.capture3,
                node_id: ($fault_parts.0.capture4 | into int),
                service_id: ($fault_parts.0.capture5 | into int)
              }
            } else { null }
          } else { null }
        } else { null }

        # Determine log type
        let log_type = if ($message | str contains "ProcessNewFaults") {
          "fault_detected"
        } else if ($message | str contains "ResolveFault") {
          if ($message | str contains "Resolving") { "fault_resolving" } else { "fault_resolved" }
        } else if ($message | str contains "CheckBlockServicesUnhealthy") {
          "health_check"
        } else {
          "other"
        }

        {
          host: $parsed.capture0,
          timestamp: ($parsed.capture1 | into datetime),
          node: $parsed.capture2,
          service: $parsed.capture3,
          log_type: $log_type,
          fault_info: $fault_info,
          raw_message: $message
        }
      }
    }
  | where $it != null
}

# Helper function to summarize faults
def summarize-faults [] {
  group-by fault_info.fault_id
  | transpose fault_id events
  | each { |row|
      let fault_events = $row.events
      let first_event = ($fault_events | first)
      let last_event = ($fault_events | last)

      {
        fault_id: $first_event.fault_info.fault_id,
        severity: $first_event.fault_info.severity,
        code: $first_event.fault_info.code,
        node_id: $first_event.fault_info.node_id,
        service_id: $first_event.fault_info.service_id,
        first_seen: $first_event.timestamp,
        last_seen: $last_event.timestamp,
        status: $last_event.log_type,
        event_count: ($fault_events | length)
      }
    }
  | sort-by first_seen
}

# Usage examples:
# parse-solidfire-logs "logfile.txt" | where log_type == "fault_detected"
# parse-solidfire-logs "logfile.txt" | where fault_info != null | summarize-faults‚èé
